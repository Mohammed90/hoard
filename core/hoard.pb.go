// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hoard.proto

/*
Package core is a generated protocol buffer package.

It is generated from these files:
	hoard.proto

It has these top-level messages:
	Reference
	Plaintext
	Ciphertext
	Address
	StatInfo
*/
package core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Reference struct {
	Address   []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	SecretKey []byte `protobuf:"bytes,2,opt,name=secretKey,proto3" json:"secretKey,omitempty"`
	Salt      []byte `protobuf:"bytes,3,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Reference) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Reference) GetSecretKey() []byte {
	if m != nil {
		return m.SecretKey
	}
	return nil
}

func (m *Reference) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

type Plaintext struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Salt []byte `protobuf:"bytes,2,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *Plaintext) Reset()                    { *m = Plaintext{} }
func (m *Plaintext) String() string            { return proto.CompactTextString(m) }
func (*Plaintext) ProtoMessage()               {}
func (*Plaintext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Plaintext) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Plaintext) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

type Ciphertext struct {
	EncryptedData []byte `protobuf:"bytes,1,opt,name=encryptedData,proto3" json:"encryptedData,omitempty"`
}

func (m *Ciphertext) Reset()                    { *m = Ciphertext{} }
func (m *Ciphertext) String() string            { return proto.CompactTextString(m) }
func (*Ciphertext) ProtoMessage()               {}
func (*Ciphertext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Ciphertext) GetEncryptedData() []byte {
	if m != nil {
		return m.EncryptedData
	}
	return nil
}

type Address struct {
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Address) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

type StatInfo struct {
	// The address will be the same as the one passed in but is repeated to
	// make result self-describing
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// If the blob does not exist this will be false instead of returning an
	// error
	Exists bool `protobuf:"varint,2,opt,name=exists" json:"exists,omitempty"`
	// Will be 0 if the blob does not existing (or omitted under protobuf3)
	Size uint64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	// The externally resolvable location of the encrypted blob. The location
	// will be hypothetical if the blob does not exist
	Location string `protobuf:"bytes,4,opt,name=location" json:"location,omitempty"`
}

func (m *StatInfo) Reset()                    { *m = StatInfo{} }
func (m *StatInfo) String() string            { return proto.CompactTextString(m) }
func (*StatInfo) ProtoMessage()               {}
func (*StatInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *StatInfo) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *StatInfo) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *StatInfo) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *StatInfo) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func init() {
	proto.RegisterType((*Reference)(nil), "core.Reference")
	proto.RegisterType((*Plaintext)(nil), "core.Plaintext")
	proto.RegisterType((*Ciphertext)(nil), "core.Ciphertext")
	proto.RegisterType((*Address)(nil), "core.Address")
	proto.RegisterType((*StatInfo)(nil), "core.StatInfo")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Hoard service

type HoardClient interface {
	// Provide a secret reference to an encrypted blob and get the plaintext
	// data back
	Get(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Plaintext, error)
	// Push some plaintext data into storage and get its deterministically
	// generated secret reference
	Put(ctx context.Context, in *Plaintext, opts ...grpc.CallOption) (*Reference, error)
	// Process some plaintext data and get its deterministically generated
	// secret reference
	Ref(ctx context.Context, in *Plaintext, opts ...grpc.CallOption) (*Reference, error)
	// Get some information about the encrypted blob stored at an address,
	// including whether it exists
	Stat(ctx context.Context, in *Address, opts ...grpc.CallOption) (*StatInfo, error)
	// Output the encrypted blob
	Cat(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Ciphertext, error)
}

type hoardClient struct {
	cc *grpc.ClientConn
}

func NewHoardClient(cc *grpc.ClientConn) HoardClient {
	return &hoardClient{cc}
}

func (c *hoardClient) Get(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Plaintext, error) {
	out := new(Plaintext)
	err := grpc.Invoke(ctx, "/core.Hoard/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hoardClient) Put(ctx context.Context, in *Plaintext, opts ...grpc.CallOption) (*Reference, error) {
	out := new(Reference)
	err := grpc.Invoke(ctx, "/core.Hoard/Put", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hoardClient) Ref(ctx context.Context, in *Plaintext, opts ...grpc.CallOption) (*Reference, error) {
	out := new(Reference)
	err := grpc.Invoke(ctx, "/core.Hoard/Ref", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hoardClient) Stat(ctx context.Context, in *Address, opts ...grpc.CallOption) (*StatInfo, error) {
	out := new(StatInfo)
	err := grpc.Invoke(ctx, "/core.Hoard/Stat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hoardClient) Cat(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Ciphertext, error) {
	out := new(Ciphertext)
	err := grpc.Invoke(ctx, "/core.Hoard/Cat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Hoard service

type HoardServer interface {
	// Provide a secret reference to an encrypted blob and get the plaintext
	// data back
	Get(context.Context, *Reference) (*Plaintext, error)
	// Push some plaintext data into storage and get its deterministically
	// generated secret reference
	Put(context.Context, *Plaintext) (*Reference, error)
	// Process some plaintext data and get its deterministically generated
	// secret reference
	Ref(context.Context, *Plaintext) (*Reference, error)
	// Get some information about the encrypted blob stored at an address,
	// including whether it exists
	Stat(context.Context, *Address) (*StatInfo, error)
	// Output the encrypted blob
	Cat(context.Context, *Address) (*Ciphertext, error)
}

func RegisterHoardServer(s *grpc.Server, srv HoardServer) {
	s.RegisterService(&_Hoard_serviceDesc, srv)
}

func _Hoard_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HoardServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.Hoard/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HoardServer).Get(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hoard_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Plaintext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HoardServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.Hoard/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HoardServer).Put(ctx, req.(*Plaintext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hoard_Ref_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Plaintext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HoardServer).Ref(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.Hoard/Ref",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HoardServer).Ref(ctx, req.(*Plaintext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hoard_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HoardServer).Stat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.Hoard/Stat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HoardServer).Stat(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hoard_Cat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HoardServer).Cat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.Hoard/Cat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HoardServer).Cat(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

var _Hoard_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.Hoard",
	HandlerType: (*HoardServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Hoard_Get_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Hoard_Put_Handler,
		},
		{
			MethodName: "Ref",
			Handler:    _Hoard_Ref_Handler,
		},
		{
			MethodName: "Stat",
			Handler:    _Hoard_Stat_Handler,
		},
		{
			MethodName: "Cat",
			Handler:    _Hoard_Cat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hoard.proto",
}

func init() { proto.RegisterFile("hoard.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 304 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xcd, 0x4a, 0xf3, 0x40,
	0x14, 0x25, 0x4d, 0xbe, 0x36, 0xb9, 0x9f, 0x55, 0x99, 0x85, 0x84, 0xe0, 0xa2, 0xc4, 0x9f, 0x76,
	0x95, 0x45, 0xfb, 0x04, 0x52, 0x41, 0xc5, 0x4d, 0x19, 0x17, 0xae, 0xc7, 0xe4, 0x86, 0x06, 0x42,
	0x26, 0xcc, 0x5c, 0xa1, 0xf5, 0x2d, 0x7d, 0x23, 0xc9, 0x64, 0x9c, 0xf8, 0x83, 0xe2, 0xee, 0x9e,
	0x73, 0xcf, 0x09, 0xe7, 0x9e, 0x0c, 0xfc, 0xdf, 0x4a, 0xa1, 0x8a, 0xac, 0x55, 0x92, 0x24, 0x0b,
	0x72, 0xa9, 0x30, 0x7d, 0x84, 0x88, 0x63, 0x89, 0x0a, 0x9b, 0x1c, 0x59, 0x0c, 0x13, 0x51, 0x14,
	0x0a, 0xb5, 0x8e, 0xbd, 0x99, 0xb7, 0x38, 0xe0, 0xef, 0x90, 0x9d, 0x42, 0xa4, 0x31, 0x57, 0x48,
	0xf7, 0xb8, 0x8f, 0x47, 0x66, 0x37, 0x10, 0x8c, 0x41, 0xa0, 0x45, 0x4d, 0xb1, 0x6f, 0x16, 0x66,
	0x4e, 0x57, 0x10, 0x6d, 0x6a, 0x51, 0x35, 0x84, 0x3b, 0xea, 0x04, 0x85, 0x20, 0x61, 0xbf, 0x6a,
	0x66, 0x67, 0x1a, 0x7d, 0x30, 0x2d, 0x01, 0xd6, 0x55, 0xbb, 0x45, 0x65, 0x5c, 0xe7, 0x30, 0xc5,
	0x26, 0x57, 0xfb, 0x96, 0xb0, 0xb8, 0x1e, 0xec, 0x9f, 0xc9, 0xf4, 0x0c, 0x26, 0x57, 0x36, 0xe5,
	0x8f, 0xf9, 0xd3, 0x1a, 0xc2, 0x07, 0x12, 0x74, 0xd7, 0x94, 0xf2, 0x97, 0x2b, 0x4f, 0x60, 0x8c,
	0xbb, 0x4a, 0x93, 0x36, 0xa1, 0x42, 0x6e, 0x91, 0x89, 0x5a, 0xbd, 0xa0, 0xb9, 0x2f, 0xe0, 0x66,
	0x66, 0x09, 0x84, 0xb5, 0xcc, 0x05, 0x55, 0xb2, 0x89, 0x83, 0x99, 0xb7, 0x88, 0xb8, 0xc3, 0xcb,
	0x57, 0x0f, 0xfe, 0xdd, 0x76, 0x55, 0xb3, 0x39, 0xf8, 0x37, 0x48, 0xec, 0x28, 0xeb, 0xca, 0xce,
	0x5c, 0xd3, 0x89, 0x25, 0x86, 0x86, 0xe6, 0xe0, 0x6f, 0x9e, 0x9d, 0xd0, 0xf1, 0xc9, 0x57, 0x67,
	0x27, 0xe4, 0x58, 0xfe, 0x41, 0x78, 0x01, 0x41, 0x77, 0x32, 0x9b, 0xf6, 0x0b, 0xdb, 0x51, 0x72,
	0xd8, 0x43, 0xd7, 0xc6, 0x25, 0xf8, 0xeb, 0xef, 0xaa, 0xe3, 0x1e, 0x0e, 0x3f, 0xe3, 0x69, 0x6c,
	0x5e, 0xcd, 0xea, 0x2d, 0x00, 0x00, 0xff, 0xff, 0xd6, 0xa5, 0x01, 0x67, 0x44, 0x02, 0x00, 0x00,
}
